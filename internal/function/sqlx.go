package function

import "text/template"

// Query to database
var selectContext *template.Template = template.Must(template.New("selectContext").Parse(`
query := {{.Query}}
err := d.db.SelectContext(ctx, &{{.Dest}}, query)
if err != nil {
	return {{.OutputsWithErr}}
}
`))

var getContext *template.Template = template.Must(template.New("getContext").Parse(`
query := {{.Query}}
err := d.db.GetContext(ctx, &{{.Dest}}, query)
if err != nil {
	if err == sql.ErrNoRows {
		return {{.OutputsWithNotFoundErr}}
	}

	return nil, err
}
`))

var namedExecContext *template.Template = template.Must(template.New("namedExecContext").Parse(`
query := {{.Query}}
_, err := d.db.NamedExecContext(ctx, query, {{.Dest}})
if err != nil {
	return {{.OutputsWithErr}}
}
`))

var execContext *template.Template = template.Must(template.New("execContext").Parse(`
_, err := d.db.ExecContext(ctx, query, {{.ExecVars}})
if err != nil {
	return {{.OutputsWithErr}}
}
`))

// signature is function's signature
var signature *template.Template = template.Must(template.New("signature").Parse(`
{{.FuncName}}(ctx context.Context, {{.Inputs}}) ({{.Outputs}})
`))

// function is function's body
var function *template.Template = template.Must(template.New("function").Parse(`
func (d *database{{.ModelName}}) {{.Signature}} {
	{{.DesStructTemplate}}

	var dst {{.Model}}

	{{.ExecQueryTemplate}}

	return {{.Outputs}}
}
`))

// repository is file's body
var repository *template.Template = template.Must(template.New("repository").Parse(`
// Code generated by Crafting-Table.
// Source code: https://github.com/snapp-incubator/crafting-table

package {{.PackageName}}

import (
	"context"
	"database/sql"
	"errors"

	"github.com/jmoiron/sqlx"
)

type {{.ModelName}} interface {
	{{.Signatures}}
}

var Err{{.ModelName}}NotFound = errors.New("{{.TableName}} not found")

type database{{.ModelName}} struct {
	db *sqlx.DB
}

func New{{.ModelName}}(db *sqlx.DB) {{.ModelName}} {
	return &database{{.ModelName}}{db: db}
}

{{.Functions}}
`))
