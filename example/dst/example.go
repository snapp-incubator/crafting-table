// Code generated by Crafting-Table.
// Source code: https://github.com/snapp-incubator/crafting-table

package repository

import (
	"context"
	"database/sql"
	"errors"

	"github.com/jmoiron/sqlx"
	"github.com/snapp-incubator/crafting-table/example/src"
)

type Example interface {
	Insert(ctx context.Context, example *src.Example) error
	GetExamples(ctx context.Context) (*[]src.Example, error)
	GetByVar1AndVar2(ctx context.Context, var1 int, var2 string) (*src.Example, error)
	GetByVar2AndVar4(ctx context.Context, var2 string, var4 bool) (*src.Example, error)
	GetByVar3(ctx context.Context, var3 bool) (*src.Example, error)
	Update(ctx context.Context, var1 int, example src.Example) (int64, error)
	UpdateVar3(ctx context.Context, var1 int, var2 string, var3 bool) (int64, error)
	UpdateVar2AndVar3(ctx context.Context, var4 bool, var2 string, var3 bool) (int64, error)
	GetAggregateByVar1(ctx context.Context, var1 int) (*int, error)
}

var ErrExampleNotFound = errors.New("example not found")

type mysqlExample struct {
	db *sqlx.DB
}

func NewMySQLExample(db *sqlx.DB) Example {
	return &mysqlExample{db: db}
}

func (r *mysqlExample) Insert(ctx context.Context, example *src.Example) error {
	_, err := r.db.NamedExecContext(ctx, "INSERT INTO example ("+
		"var1, var2, var3, var4"+
		") VALUES ("+
		":var1, :var2, :var3, :var4)",
		example)

	if err != nil {
		return err
	}

	return nil
}

func (r *mysqlExample) Update(ctx context.Context, var1 int, example src.Example) (int64, error) {
	example.Var1 = var1

	result, err := r.db.NamedExecContext(ctx, "UPDATE example "+
		"SET "+
		"var1 = :var1, var2 = :var2, var3 = :var3, var4 = :var4 "+
		"WHERE var1 = :var1",
		example,
	)

	if err != nil {
		return 0, err
	}

	return result.RowsAffected()
}

func (r *mysqlExample) UpdateVar3(ctx context.Context, var1 int, var2 string, var3 bool) (int64, error) {
	query := "UPDATE example SET " +
		"var3 = ? " +
		"WHERE var1 = ? AND var2 = ?;"

	result, err := r.db.ExecContext(ctx, query, var3, var1, var2)

	if err != nil {
		return 0, err
	}

	return result.RowsAffected()
}

func (r *mysqlExample) UpdateVar2AndVar3(ctx context.Context, var4 bool, var2 string, var3 bool) (int64, error) {
	query := "UPDATE example SET " +
		"var2 = ?, var3 = ? " +
		"WHERE var4 = ?;"

	result, err := r.db.ExecContext(ctx, query, var2, var3, var4)

	if err != nil {
		return 0, err
	}

	return result.RowsAffected()
}

func (r *mysqlExample) GetExamples(ctx context.Context) (*[]src.Example, error) {
	var example []src.Example
	err := r.db.SelectContext(ctx, &example, "SELECT * from example")
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrExampleNotFound
		}

		return nil, err
	}

	return &example, nil
}

func (r *mysqlExample) GetByVar1AndVar2(ctx context.Context, var1 int, var2 string) (*src.Example, error) {
	var example src.Example

	err := r.db.GetContext(ctx, &example, "SELECT * FROM example "+
		"WHERE var1 = ? AND var2 = ?",
		var1, var2,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrExampleNotFound
		}

		return nil, err
	}

	return &example, nil
}

func (r *mysqlExample) GetByVar2AndVar4(ctx context.Context, var2 string, var4 bool) (*src.Example, error) {
	var example src.Example

	err := r.db.GetContext(ctx, &example, "SELECT * FROM example "+
		"WHERE var2 = ? AND var4 = ?",
		var2, var4,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrExampleNotFound
		}

		return nil, err
	}

	return &example, nil
}

func (r *mysqlExample) GetByVar3(ctx context.Context, var3 bool) (*src.Example, error) {
	var example src.Example

	err := r.db.GetContext(ctx, &example, "SELECT * FROM example "+
		"WHERE var3 = ?",
		var3,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrExampleNotFound
		}

		return nil, err
	}

	return &example, nil
}

func (r *mysqlExample) GetAggregateByVar1(ctx context.Context, var1 int) (*int, error) {
	var res struct {
		result int `db:"count"`
	}

	err := r.db.SelectContext(ctx, &res, "SELECT COUNT(var2) AS count FROM example "+
		"WHERE var1 = ? GROUP BY var1, var2",
		var1,
	)

	if err != nil {
		return nil, err
	}

	return &res.result, nil
}
